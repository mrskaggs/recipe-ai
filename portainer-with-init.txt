UPDATED DOCKER-COMPOSE FOR PORTAINER (WITH FILE INITIALIZATION):

version: "3.8"

services:
  postgres:
    image: postgres:15-alpine
    container_name: recipe-postgres
    environment:
      POSTGRES_DB: recipes
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password123
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - recipe-network

  api:
    image: node:18-alpine
    container_name: recipe-api
    working_dir: /app
    environment:
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: recipes
      DB_USER: postgres
      DB_PASSWORD: password123
      PORT: 3001
      NODE_ENV: production
    ports:
      - "3001:3001"
    command: |
      sh -c '
      echo "Creating package.json..." &&
      cat > package.json << EOF
      {
        "name": "recipe-api",
        "version": "1.0.0",
        "description": "Recipe tracking API with PostgreSQL",
        "main": "server.js",
        "scripts": {
          "start": "node server.js"
        },
        "dependencies": {
          "express": "^4.18.2",
          "pg": "^8.11.3",
          "cors": "^2.8.5",
          "dotenv": "^16.3.1",
          "helmet": "^7.0.0"
        }
      }
      EOF
      echo "Installing dependencies..." &&
      npm install --production &&
      echo "Creating server.js..." &&
      cat > server.js << "SERVEREOF"
      const express = require("express");
      const cors = require("cors");
      const helmet = require("helmet");
      const { Pool } = require("pg");
      
      const app = express();
      const port = process.env.PORT || 3001;
      
      app.use(helmet());
      app.use(cors());
      app.use(express.json({ limit: "10mb" }));
      
      const pool = new Pool({
        user: process.env.DB_USER || "postgres",
        host: process.env.DB_HOST || "localhost",
        database: process.env.DB_NAME || "recipes",
        password: process.env.DB_PASSWORD || "password",
        port: process.env.DB_PORT || 5432,
      });
      
      app.get("/health", (req, res) => {
        res.json({ status: "OK", message: "Recipe API is running" });
      });
      
      app.get("/api/recipes", async (req, res) => {
        try {
          const result = await pool.query("SELECT * FROM recipes ORDER BY created_at DESC");
          res.json(result.rows);
        } catch (err) {
          console.error("Error fetching recipes:", err);
          res.status(500).json({ error: "Internal server error" });
        }
      });
      
      app.post("/api/recipes", async (req, res) => {
        const client = await pool.connect();
        try {
          await client.query("BEGIN");
          const recipeData = req.body[0]?.output || req.body;
          const { title, servings, macros_per_serving } = recipeData;
          
          const result = await client.query(
            "INSERT INTO recipes (title, servings, calories, protein_g, carbs_g, fat_g) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id",
            [title, servings, macros_per_serving?.calories || 0, macros_per_serving?.protein_g || 0, macros_per_serving?.carbs_g || 0, macros_per_serving?.fat_g || 0]
          );
          
          await client.query("COMMIT");
          res.status(201).json({ message: "Recipe created successfully", recipeId: result.rows[0].id });
        } catch (err) {
          await client.query("ROLLBACK");
          console.error("Error creating recipe:", err);
          res.status(500).json({ error: "Internal server error" });
        } finally {
          client.release();
        }
      });
      
      app.listen(port, () => {
        console.log("Recipe API server running on port " + port);
      });
      SERVEREOF
      echo "Starting server..." &&
      node server.js
      '
    depends_on:
      - postgres
    networks:
      - recipe-network
    restart: unless-stopped

volumes:
  postgres_data:

networks:
  recipe-network:
    driver: bridge

INSTRUCTIONS:
1. Replace your current docker-compose in Portainer with this version
2. This version creates the files automatically inside the container
3. No need to upload files separately
4. Deploy the stack
